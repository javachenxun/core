### 1.[缓存常见问题]
<!--
https://zhuanlan.zhihu.com/p/26151305
https://juejin.im/post/5c9a67ac6fb9a070cb24bf34
-->
#### 1.1.缓存穿透
		
    场景：缓存穿透是指查询【一个】根本不存在的数据，缓存层和存储层都不会命中。
    问题：恶意大量请求，击垮服务器
    解决:缓存中缓存空对象；然后再把key放到一个集合中，在缓冲前在过滤一遍【BloomFilter(布隆过滤器)】。
    不足：带来缓存空间开销;

#### 1.2.缓存击穿

    场景：高并发的系统中，大量的请求同时查询【一个key】时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去，这种现象我们称为缓存击穿。
    问题：会造成某一时刻数据库请求量过大，压力剧增
    解决：第一个线程加锁，查询，放置到缓存；其他线程等待锁，再查询；
    不足：

#### 1.3.缓存雪崩

    场景：缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了。
    问题：会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉
    解决：
        事前，使用集群缓存，保证缓存服务的高可用（主从+哨兵）
        事中：ehcache本地缓存 + Hystrix限流&降级,避免MySQL被打死
        事后：开启Redis持久化机制，尽快恢复缓存集群
    不足：
		
#### 1.4.热点Key
    场景：【一些热点的key】数据来说，当缓存失效以后会存在大量的请求过来
    问题：大量请求打到数据库去，从而可能导致数据库崩溃的情况
    
    解决：互斥锁，参考缓存击穿解决办法
    不足：由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。
    
    解决：设置不同的失效时间（比如在一个基础的时间上加上或者减去一个范围内的随机值）
    不足：

### 2.如何保障数据一致性
	先更新DB,再删除缓存:可以保证数据一致性
	先删除缓存,再更新DB:造成数据不一致